package com.example.mg.service;

import com.example.mg.auth.TokenProvider;
import com.example.mg.buffer.BufferedId;
import com.example.mg.buffer.ReactiveIdBuffer;
import com.example.mg.client.MgApiClient;
import com.example.mg.config.MgProperties;
import com.example.mg.jms.DetailJmsPublisher;
import com.example.mg.mapper.ItemDetailsMapper;
import com.example.mg.model.ItemDetails;
import com.example.mg.state.MgApiState;
import com.example.mg.store.ItemDetailsStore;

import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import reactor.core.Disposable;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.util.List;

@Service
public class MgDetailsConsumer {

    private static final Logger log =
            LoggerFactory.getLogger(MgDetailsConsumer.class);

    private final ReactiveIdBuffer buffer;
    private final MgApiClient api;
    private final MgApiState state;
    private final ItemDetailsStore store;
    private final ItemDetailsMapper mapper;
    private final DetailJmsPublisher jmsPublisher;
    private final MgProperties props;
    private final TokenProvider tokenProvider;

    private volatile Disposable subscription;

    public MgDetailsConsumer(
            ReactiveIdBuffer buffer,
            MgApiClient api,
            MgApiState state,
            ItemDetailsStore store,
            ItemDetailsMapper mapper,
            DetailJmsPublisher jmsPublisher,
            MgProperties props,
            TokenProvider tokenProvider) {

        this.buffer = buffer;
        this.api = api;
        this.state = state;
        this.store = store;
        this.mapper = mapper;
        this.jmsPublisher = jmsPublisher;
        this.props = props;
        this.tokenProvider = tokenProvider;
    }

    /**
     * Always start consumer at boot
     */
    @PostConstruct
    public void start() {

        if (subscription != null && !subscription.isDisposed()) {
            return;
        }

        log.info("Starting MG Detail Consumer");

        subscription =
            Mono.defer(tokenProvider::getToken)

                .flatMapMany(token ->

                    buffer.stream()

                        // process IDs (bounded concurrency)
                        .flatMap(
                            bid -> processOne(token, bid),
                            props.getDetailConcurrency()
                        )
                )

                // ðŸ”¥ batch DB insert
                .bufferTimeout(
                    props.getDbBatchSize(),      // e.g. 200
                    props.getDbBatchWindow()     // e.g. 2s
                )

                // DB insert â†’ JMS â†’ state COMPLETE
                .flatMap(this::handleBatch)

                // consumer must NEVER die
                .retryWhen(
                    Retry.backoff(
                        Long.MAX_VALUE,
                        Duration.ofSeconds(5)
                    )
                )

                .subscribe(
                    v -> {},
                    e -> log.error("DETAIL CONSUMER TERMINATED", e)
                );
    }

    /**
     * Process ONE ID â†’ ItemDetails
     */
    private Mono<ItemDetails> processOne(String token,
                                         BufferedId bid) {

        return state.markInProgress(bid.loadId(), bid.id())

            .then(api.details(token, bid.id()))

            .map(mapper::toItemDetails)

            // failure â†’ mark FAILED and drop
            .onErrorResume(e ->
                state.markFailed(
                    bid.loadId(),
                    bid.id(),
                    e.getMessage()
                ).then(Mono.empty())
            );
    }

    /**
     * Handle batch AFTER bufferTimeout
     */
    private Mono<Void> handleBatch(List<ItemDetails> items) {

        if (items.isEmpty()) {
            return Mono.empty();
        }

        return store.insertBatch(items)

            // JMS publish AFTER DB success
            .thenMany(
                Flux.fromIterable(items)
                    .flatMap(jmsPublisher::publish)
            )

            // mark COMPLETE AFTER JMS
            .thenMany(
                Flux.fromIterable(items)
                    .flatMap(item ->
                        state.markCompleteByExtId(item.id())
                    )
            )

            .then();
    }
}
